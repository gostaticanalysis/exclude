package exclude_test

import (
	"bytes"
	"flag"
	"fmt"
	"html/template"
	"path/filepath"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"golang.org/x/tools/go/analysis"
	"golang.org/x/tools/go/analysis/analysistest"

	"github.com/gostaticanalysis/exclude"
)

func TestGeneratedFile(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		src  string
		want bool // is reported?
	}{
		"autogen":    {"// Code generated by test; DO NOT EDIT.", false},
		"notautogen": {"//Code generated by test; DO NOT EDIT.", true},
		"empty":      {"", true},
		"blank":      {"// Code generated by test; DO NOT EDIT.\n", false},
	}

	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			path := filepath.Join(name, name+".go")
			dir := writeFiles(t, map[string]string{
				path: fmt.Sprintf("%s\npackage %s", tt.src, name),
			})
			var rec reportRecoder
			analysistest.Run(t, dir, rec.new(exclude.GeneratedFile, -1), name)
			if got := rec.isReported(); got != tt.want {
				t.Errorf("want %v but got %v", tt.want, got)
			}
		})
	}
}

func TestTestFile(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		file string
		want bool // is reported?
	}{
		"testfile": {"a_test.go", false},
		"not":      {"a.go", true},
	}

	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			path := filepath.Join(name, tt.file)
			dir := writeFiles(t, map[string]string{
				path: fmt.Sprintf("package %s", name),
			})
			var rec reportRecoder
			analysistest.Run(t, dir, rec.new(exclude.TestFile, 1), name)
			if got := rec.isReported(); got != tt.want {
				t.Errorf("want %v but got %v", tt.want, got)
			}
		})
	}
}

func TestFileWithPattern(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		pattern string
		file    string
		want    bool // is reported?
	}{
		"match":   {`^.+\.pb\.go$`, "a.pb.go", false},
		"unmatch": {`^.+\.pb\.go$`, "a.go", true},
	}

	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			path := filepath.Join(name, tt.file)
			dir := writeFiles(t, map[string]string{
				path: fmt.Sprintf("package %s", name),
			})
			var rec reportRecoder
			a := rec.new(exclude.FileWithPattern, 1)
			a.Flags.Set("exclude-file", tt.pattern)
			analysistest.Run(t, dir, a, name)
			if got := rec.isReported(); got != tt.want {
				t.Errorf("want %v but got %v", tt.want, got)
			}
		})
	}
}

func TestFlags(t *testing.T) {
	t.Parallel()
	cases := map[string]struct {
		args    string
		flags   string
		remains string
	}{
		"set":      {"-all-exclude-testfile=false mypkg", "exclude-testfile=false", "mypkg"},
		"onlyargs": {"mypkg", "", "mypkg"},
	}

	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			a := exclude.By(new(analysis.Analyzer), exclude.AllFuncs...)

			{ // check remains
				args := strings.Split(tt.args, " ")
				got, err := exclude.Flags(args, a)
				if err != nil {
					t.Fatal("unexpected error:", err)
				}

				want := strings.Split(tt.remains, " ")
				if diff := cmp.Diff(want, got); diff != "" {
					t.Error("remains:", diff)
				}
			}

			if tt.flags != "" { // check flags
				flags := strings.Split(tt.flags, " ")
				want := make(map[string]string, len(flags))
				for _, f := range flags {
					kv := strings.Split(f, "=")
					if len(kv) != 2 {
						t.Fatal("invalid flags", f)
					}
					want[kv[0]] = kv[1]
				}

				got := map[string]string{}
				a.Flags.Visit(func(f *flag.Flag) {
					got[f.Name] = f.Value.String()
				})

				if diff := cmp.Diff(want, got); diff != "" {
					t.Error("flags:", diff)
				}
			}
		})
	}
}

func TestLintIgnoreComment(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		comment string
		want    bool // is reported?
	}{
		"nocomment": {"", true},
		"ignore":    {"//lint:ignore {{.}} reason", false},
		"missname":  {"//lint:ignore missname reason", true},
		"noreason":  {"//lint:ignore {{.}}", true},
	}

	for name, tt := range cases {
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			path := filepath.Join(name, name+".go")
			var rec reportRecoder
			a := rec.new(exclude.LintIgnoreComment, 3)
			var comment bytes.Buffer
			if err := template.Must(template.New(name).Parse(tt.comment)).Execute(&comment, a.Name); err != nil {
				t.Fatal("unexpected error")
			}
			dir := writeFiles(t, map[string]string{
				path: fmt.Sprintf("package %s\n%s\nvar _ struct{}", name, &comment),
			})
			analysistest.Run(t, dir, a, name)
			if got := rec.isReported(); got != tt.want {
				t.Errorf("want %v but got %v", tt.want, got)
			}
		})
	}
}
